/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.simulation.transportation.components;

import com.simulation.contracts.transportation.components.IMap;
import com.simulation.contracts.transportation.components.IScenario;
import com.simulation.contracts.transportation.components.ISimulationVisualize;
import com.simulation.contracts.transportation.components.IVehicle;
import com.simulation.contracts.transportation.units.ILength;
import com.simulation.contracts.transportation.units.ITime;
import com.simulation.transportation.units.Length;
import com.simulation.transportation.units.Time;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JFrame;
import javax.swing.Timer;

/**
 *
 * @author hakantek
 */
public class SimulationVisualize extends javax.swing.JFrame implements ActionListener, ISimulationVisualize {

	private static final long serialVersionUID = 1L;
	/**
     * Creates new form SimulationVisualize
     * @param scenario
     * @param delay
     * @param movingTime
     */
    protected SimulationVisualize(IScenario scenario, int delay, ITime movingTime) {
        this.scenario = scenario;
        
        /* create and start timer */
        this.timer = new Timer(delay, this);
        this.movingTime = movingTime;
        
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /* run simulation visulation */
    @Override
    public void run(double leftSpace, double rightSpace, double topSpace, double bottomSpace,
            ILength nodeR, Color nodeColor, Font nodeTextFont, Color nodeTextColor,
            Color roadColor, Color railColor, Color seaColor) {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SimulationVisualize.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SimulationVisualize.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SimulationVisualize.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SimulationVisualize.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
                
        /* assign visual parameters of node */
        this.nodeR = nodeR;
        this.nodeColor = nodeColor;
        this.nodeTextFont = nodeTextFont;
        this.nodeTextColor = nodeTextColor;
        
        /* assign parameters of links */
        this.roadColor = roadColor;
        this.railColor = railColor;
        this.seaColor = seaColor;
        
        /* find screen size */
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        
        /* calculate max x_pos and max y_pos */
        ILength max_xPos = Length.Meter(0);
        ILength max_yPos = Length.Meter(0);
        for(IMap.INode node:this.scenario.getNodes()){
            /* değişecek */
            if(node.getXPos().sum(nodeR.division(2)).isGreaterThan(max_xPos))
                max_xPos = Length.Meter(node.getXPos().sum(nodeR.division(2)).getMeter());
            
            if(node.getYPos().sum(nodeR.division(2)).isGreaterThan(max_yPos))
                max_yPos = Length.Meter(node.getYPos().sum(nodeR.division(2)).getMeter());
        }
        
        /* calculate size ratio, assign bottom space and left space */
        this.topSpace = topSpace;
        this.leftSpace = leftSpace;
        this.sizeRatio = Math.min((screenSize.width - leftSpace - rightSpace)/max_xPos.getMeter(),
                (screenSize.height - topSpace - bottomSpace)/max_yPos.getMeter());
  
        /* start timer */
        this.timer.start();
        
        /* show */
        this.setExtendedState(JFrame.MAXIMIZED_BOTH); 
        this.setVisible(true);
    }
    /* stop simulation */
    @Override
    public void stop(){
        this.timer.stop();
    }
    
    /* timer of simulation */
    private Timer timer;
    @Override
    public void setTimerDelay(int delay){
        this.timer.setDelay(delay);
    }
    private ITime movingTime;
    @Override
    public void setMovingTime(ITime movingTime) {
        this.movingTime = movingTime;
    }
    
    /* scenario */
    private IScenario scenario;
    
    /* visual parameters of node */
    private ILength nodeR;
    @Override
    public void setLenght(ILength length){
        this.nodeR = length;
    }
    
    private Color nodeColor;
    public void setNodeColor(Color color){
        this.nodeColor = color;
    }
    
    private Font nodeTextFont;
    public void setNodeTextFont(Font nodeTextFont) {
        this.nodeTextFont = nodeTextFont;
    }
    
    private Color nodeTextColor;
    public void setNodeTextColor(Color nodeTextColor) {
        this.nodeTextColor = nodeTextColor;
    }
    
    /* visual parameters of link */
    private Color roadColor;
    public Color getRoadColor() {
        return roadColor;
    }
    
    private Color railColor;
    public Color getRailColor() {
        return railColor;
    }
    
    private Color seaColor;
    public Color getSeaColor() {
        return seaColor;
    }

   /* visual parameters of link */
    
    
    /* paints components of map */
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        this.paintLinks(g);
        this.paintNodes(g);
        this.paitVehicles(g);
    }
    private void paintNodes(Graphics g){
        /* draw nodes */    
        g.setColor(this.nodeColor);
        this.scenario.getNodes().stream().forEach((node) -> {
            g.fillOval(this.x_pix(node.getXPos()), this.y_pix(node.getYPos()), (int)this.nodeR.getMeter(), (int)this.nodeR.getMeter());
        });
        
        /* draw node names */
        g.setColor(this.nodeTextColor);
        g.setFont(this.nodeTextFont);
        this.scenario.getNodes().stream().forEach((node) -> {
            g.drawString(node.getName(), this.x_pix(node.getXPos(), this.nodeR.division(2.0)), this.y_pix(node.getYPos(), this.nodeR.division(2.0)));
        });
        
    }
    private void paintLinks(Graphics g){
        /* düzenlenecek */
        //Graphics2D g2 = (Graphics2D) g;
        //g2.setStroke(new BasicStroke(5));
        
        //g2.setColor(this.roadColor);
        for(IMap.ILink road : this.scenario.getRoads()){
            g.drawLine(this.x_pix(road.getOutNode().getXPos().sum(this.nodeR.division(2))),
                    this.y_pix(road.getOutNode().getYPos().sum(this.nodeR.division(2))),
                    this.x_pix(road.getEntryNode().getXPos().sum(this.nodeR.division(2))),
                    this.y_pix(road.getEntryNode().getYPos().sum(this.nodeR.division(2))));
        }
        g.setColor(this.railColor);
        for(IMap.ILink rail : this.scenario.getRails()){
            g.drawLine(this.x_pix(rail.getOutNode().getXPos().sum(this.nodeR.division(2))),
                    this.y_pix(rail.getOutNode().getYPos().sum(this.nodeR.division(2))),
                    this.x_pix(rail.getEntryNode().getXPos().sum(this.nodeR.division(2))),
                    this.y_pix(rail.getEntryNode().getYPos().sum(this.nodeR.division(2))));
        }
        g.setColor(this.seaColor);
        for(IMap.ILink sea : this.scenario.getSeas()){
            g.drawLine(this.x_pix(sea.getOutNode().getXPos().sum(this.nodeR.division(2))),
                    this.y_pix(sea.getOutNode().getYPos().sum(this.nodeR.division(2))),
                    this.x_pix(sea.getEntryNode().getXPos().sum(this.nodeR.division(2))),
                    this.y_pix(sea.getEntryNode().getYPos().sum(this.nodeR.division(2))));
        }
    }
    private void paitVehicles(Graphics g){
        g.setColor(Color.ORANGE);
        
        for(IVehicle vehicle : scenario.getVehicles())
            g.fillOval(this.x_pix(vehicle.getX_pos()), this.y_pix(vehicle.getY_pos()), 25, 25);
    }
    @Override
    public void actionPerformed(ActionEvent e) {
        this.scenario.move(movingTime);
        repaint();
    }
   
    /* resize as sceen */
    private double sizeRatio;
    private double topSpace;
    private double leftSpace;
    /*
    public int x_pix(Length x_pos){
        return (int)(x_pos.getBase()*this.sizeRatio + leftSpace);
    }
    public int x_pix(Length x_pos, double shift){
        return (int)(x_pos.sum(shift).getBase()*this.sizeRatio + leftSpace);
    }
    public int y_pix(Length y_pos){
        return (int)(y_pos.getBase()*this.sizeRatio + this.topSpace);
    }
    public int y_pix(Length y_pos, double shift){
        return (int)(y_pos.SumWith(shift).getBase()*this.sizeRatio + this.topSpace);
    }
    */
    
    public int x_pix(ILength x_pos){
        return (int)(x_pos.getBase() + leftSpace);
    }
    public int x_pix(ILength x_pos, ILength shift){
        return (int)(x_pos.sum(shift).getBase() + leftSpace);
    }
    public int y_pix(ILength y_pos){
        return (int)(y_pos.getBase() + this.topSpace);
    }
    public int y_pix(ILength y_pos, ILength shift){
        return (int)(y_pos.sum(shift).getBase() + this.topSpace);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}